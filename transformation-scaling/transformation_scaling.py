# -*- coding: utf-8 -*-
"""transformation_scaling.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/13Nlrt-Z7MPFDDxYEZrhQhyCJkZnnk6PW

QUIZ
1. Robust scaler is best for data with outliers.
2. Standard scaler produces data that's normally distributed with a mean of 0 and variance of 1.
3. MaxAbs will not destroy any sparsity because it doesn't shift the data to the center. Sparsity is where most data values are zero.
4. MinMax is the best to scale to a given bound/range.
"""

import pandas as pd
df = pd.read_csv('/content/mtcars_mod.csv')

df

import seaborn as sns

from sklearn.preprocessing import MinMaxScaler, StandardScaler, RobustScaler, MaxAbsScaler

#1
sns.kdeplot(df[['disp']])

mms = MinMaxScaler()
stds = StandardScaler()
mabs = MaxAbsScaler()
rbs = RobustScaler()

df[['disp_minmax']] = mms.fit_transform(df[['disp']])

df[['wt_stds']] = stds.fit_transform(df[['wt']])

df[['hp_mabs']] = mabs.fit_transform(df[['hp']])

df[['drat_rbs']] = rbs.fit_transform(df[['drat']])

import matplotlib.pyplot as plt

fig, ax = plt.subplots(4, 2)
sns.kdeplot(df['disp'], ax=ax[0,0])
sns.kdeplot(df['disp_minmax'], ax=ax[0,1])
sns.kdeplot(df['wt'], ax=ax[1,0])
sns.kdeplot(df['wt_stds'], ax=ax[1,1])
sns.kdeplot(df['hp'], ax=ax[2,0])
sns.kdeplot(df['hp_mabs'], ax=ax[2,1])
sns.kdeplot(df['drat'], ax=ax[3,0])
sns.kdeplot(df['drat_rbs'], ax=ax[3,1])
fig.tight_layout()

#2
from scipy.stats import boxcox, yeojohnson

df['mpg'].skew()

df['qsec'].skew()

mpg_bc, lambda_mpg = boxcox(df['mpg'])

mpg_bc

lambda_mpg

df['mpg_bc'] = mpg_bc
sns.kdeplot(df['mpg_bc'])

df['mpg_bc'].skew()

qsec_yj, lambda_qsec = yeojohnson(df['qsec'])

qsec_yj

lambda_qsec

df['qsec_yj'] = qsec_yj
sns.kdeplot(df['qsec_yj'])

df['qsec_yj'].skew()

#3
import numpy as np
from sklearn.preprocessing import Normalizer
norm = Normalizer()

norm2 = Normalizer(norm='l2')

df.info()

numeric_data = df.select_dtypes(include='number').columns

df_copy = df.copy()

df_copy[numeric_data] = norm2.fit_transform(df_copy[numeric_data])

df_copy